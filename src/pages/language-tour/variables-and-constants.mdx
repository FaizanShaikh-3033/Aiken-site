# Variables & Constants

## Variables / let-bindings

Aiken has let-bindings for declaring variables. A value can be given a name
using the keyword `let`. Names can be reused by later let-bindings.

Values assigned to let-bindings are immutable, however new bindings can shadow
previous bindings.

```aiken
let x = 1
let y = x
let x = 2

y + x == 3
```

## Module constants

Let-bindings aren't allowed in a top-level Aiken module. Yet, Aiken provides
module constants as a way to use certain fixed values in multiple places of a
Aiken project.

```aiken
const start_year = 2101
const end_year = 2111
```

Like all values in Aiken, module constants are immutable. They cannot be used as
global mutable state. When a constant is referenced, its value is inlined by
the compiler so they can be used in any place where you'd have written a
literal to begin with (e.g. when-expression guards, if clauses ...). We'll
see some example of that when dealing with control flows.

Note that you can only declare module constants for the following Aiken types:
`Int{:ak}`, `ByteArray{:ak}` and `String{:ak}`.

## Type annotations

Variables and constants can be given type annotations. These annotations serve
as documentation or can be used to provide a more specific type than the
compiler would otherwise infer.

```aiken
const name: ByteArray = "Aiken"
const size: Int = 100

let result: Bool = 14 > 42
```
