import { Callout } from "nextra-theme-docs";

# Common Design Patterns

There are number of design patterns that have been refined and enabled as Plutus has advanced from V1 to V2,
and now to V3. This document seeks to be a non-exhaustive reference to these design patterns and practices.

## Enforcing Uniqueness

Enforcing the uniqueness of policies, asset names, or new outputs is useful in a number of contexts.

### "One-Shot" Minting Policies

A validator is parameterized with an `OutputReference`, the minting validator
enforces that the inputs to the transaction contain the corresponding `UTxO` as
input. By doing this, the minting policy is ensured to only validate once and
only once (since an unspent transaction output can only be spent once, by
definition). In some designs, this logic is used for only a subset of redeemers
to allow more flexible minting policies.

#### Example:

An NFT (Non-Fungible Token) can be created using a one-shot minting policy that ensures each minted value
is validated by spending a specific UTxO provided through the transaction inputs. This minting policy uses
a validator parameter of OutputReference to confirm that the transaction spends the UTxO. Additionally, the
policy guarantees that only one token is minted, ensuring the NFT's uniqueness.

First define OutputReference as parameter and set the action type to mint or burn the token based on the
value provided in the redeemer.

``` aiken
use cardano/transaction.{OutputReference, Transaction}
use cardano/assets.{PolicyId}

pub type Action {
  Minting
  Burning
}

validator one_shot(utxo_ref: OutputReference) {
  mint(redeemer: Action, policy_id: PolicyId, self: Transaction) {
      todo @"mint and burn"
    }
  }
}
```

The validator must handle minting/burning operations and ensures that only one value is minted; it will fail otherwise.

```aiken {1, 12-17}
use aiken/collection/dict
use cardano/transaction.{OutputReference, Transaction}
use cardano/assets.{PolicyId}

pub type Action {
  Minting
  Burning
}

validator one_shot(utxo_ref: OutputReference) {
  mint(redeemer: Action, policy_id: PolicyId, self: Transaction) {
      // It checks that only one minted asset exists and will fail otherwise
      expect [(_asset_name, quantity)] = self.mint
        |> assets.tokens(policy_id)
        |> dict.to_pairs()

      todo @"Check if output is consumed"
    }
  }
}
```

To enforce uniqueness, we need to ensure that the UTxO defined as OutputReference in the validator parameters is
consumed. This is because every OutputReference is a unique combination of the Transaction ID and an Output Index
Integer. It's important to remember that the Transaction ID is a `Hash<Blake2b_256, Transaction>`, which is also a
unique identifier and will not be repeated.

``` aiken {2, 18-25}
use aiken/collection/dict
use aiken/collection/list
use cardano/transaction.{OutputReference, Transaction}
use cardano/assets.{PolicyId}

pub type Action {
  Minting
  Burning
}

validator one_shot(utxo_ref: OutputReference) {
  mint(redeemer: Action, policy_id: PolicyId, self: Transaction) {
      // It checks that only one minted asset exists and will fail otherwise
      expect [(_asset_name, quantity)] = self.mint
        |> assets.tokens(policy_id)
        |> dict.to_pairs()

      // Check if the specified UTxO reference (utxo_ref) is consumed by any input
      let is_output_consumed = list.any(inputs, fn(input) { input.output_reference == utxo_ref })

      when action is {
        Minting ->
          is_output_consumed? && (quantity == 1)?

        Burning -> (quantity == -1)? // No need to check if output is consumed for burning
      }
    }
  }
}
```

### Receipts

A validator can mint a unique receipt for a transaction by requiring that the name of the asset is any
unique value specific to the transaction where validation is set to occur. In other words, if we enforce
that only one receipt is to be minted per transaction, we can use `blake2b_256` and `cbor.serialise` to
get a unique value that can be assigned to the `AssetName` expected for the receipt from the
`OutputReference` from the first `Input` in our transactions inputs.

``` aiken
use aiken/builtin.{blake2b_256}
use aiken/cbor
use aiken/collection/dict
use aiken/collection/list
use cardano/assets.{PolicyId}
use cardano/transaction.{Transaction}

validator receipt {
  // This validator expects a minting transaction
  mint(_r: Data, policy_id: PolicyId, self: Transaction) {
    let Transaction { inputs, mint, .. } = self

    // Select the first input and concatenate its output reference and index to
    // generate the expected token name
    expect Some(first_input) = list.at(inputs, 0)
    expect [Pair(asset_name, quantity)] =
      mint |> assets.tokens(policy_id) |> dict.to_pairs()

    let expected_token_name =
      first_input.output_reference
        |> cbor.serialise
        |> blake2b_256

    // Compare the asset name with the first utxo output reference
    asset_name == expected_token_name && quantity == 1
  }

  // The validator will fail if the transaction is not for minting.
  else(_) {
    fail
  }
}
```

We could use this validator to mint a unique receipt for a transaction. It will get the first UTxO reference
and will compare it with the asset name.

### Unique Outputs

To prevent a vulnerability called 'Double Satisfaction' (see more below), one pattern is to ensure
that the output associated with a given input has its datum 'tagged' with a value which is unique to the
input. Enough info is present in the `OutputReference` of the input to create a unique value.

#### Double Satisfaction Anti-Pattern

In PlutusV1 and PlutusV2, a common anti-pattern was to predicate spending upon logic that was specific to
a given input - without ensuring the uniqueness of the corresponding output.

Let's walk through a short example:
Bob wants to sell 20 SCOIN and wants at least 5 ADA in return; the contract would require that at least
5 ADA is paid to Bob.

Step-by-step swap:

  1.- Bob sends 20 SCOIN to the validator with a datum containing his VerificationKeyHash and
      the price (5 ADA) required to get the 20 SCOIN.

  2.- Alice makes a new transaction getting the 20 SCOIN and paying 5 ADA to Bob.

  3.- Alice will get 20 SCOIN.

  4.- Bob will get 5 ADA.


``` aiken
use aiken/collection/list
use aiken/crypto.{Blake2b_224, Hash, VerificationKey}
use cardano/address
use cardano/assets.{lovelace_of, merge}
use cardano/transaction.{Output, OutputReference, Transaction}

type VerificationKeyHash =
  Hash<Blake2b_224, VerificationKey>

pub type DatumSwap {
  beneficiary: VerificationKeyHash,
  price: Int,
}

validator exploitable_swap {
  spend(
    optional_datum: Option<DatumSwap>,
    _redeemer: Data,
    _own_ref: OutputReference,
    self: Transaction,
  ) {
    expect Some(datum) = optional_datum

    let beneficiary = address.from_verification_key(datum.beneficiary)

    let user_outputs =
      list.filter(
        self.outputs,
        fn(output) { output.address == beneficiary },
      )

    let value_paid =
      list.foldl(
        user_outputs,
        assets.zero,
        fn(output, total) { merge(output.value, total) },
      )

    (lovelace_of(value_paid) >= datum.price)?
  }
}
```
So far, everything is ok, but what if we have some UTxOs locked in the validator at similar prices?

Bob wants to sell 20 XCOIN, and 20 SCOIN and wants at least 10 ADA in return for each UTxO;
the contract would require that at least 10 ADA be paid to Bob. Now Alice comes and pays Bob 10 ADA,
in the same transaction she takes both the 20 SCOIN and 20 XCOIN because the contract only ensures
that at least 10 ADA is paid to Bob.

So, this validator could potentially cause the double satisfaction antipattern, where anyone can pay once and
get every UTxO locked at the same price or less.

What can we do?
We have to ensure that each input has a corresponding unique output to pay or predicate the logic of spending any input of the
script on all of the inputs and outputs relevant to the business logic of the dApp.

Solution proposed:

First of all, we have to remember that the code in the validator will be executed for every UTxO locked to the validator address.
That we are trying to unlock. So we have to validate that every input has an output or many outputs that sum up the amount of Lovelace
asked for by the seller.

``` aiken {26-50}
use aiken/collection/list
use aiken/crypto.{Blake2b_224, Hash, VerificationKey}
use cardano/address
use cardano/assets.{lovelace_of, merge}
use cardano/transaction.{InlineDatum, Output, OutputReference, Transaction}

type VerificationKeyHash =
  Hash<Blake2b_224, VerificationKey>

pub type DatumSwap {
  beneficiary: VerificationKeyHash,
  price: Int,
}

validator swap {
  spend(
    optional_datum: Option<DatumSwap>,
    _redeemer: Data,
    own_ref: OutputReference,
    self: Transaction,
  ) {
    expect Some(datum) = optional_datum

    let beneficiary = address.from_verification_key(datum.beneficiary)

    // We will get all UTxO outputs with a datum equal to the UTxO input's reference
    // we are validating. We have to remember that this code will be executed for every
    // UTxO locked to the validator address that we are trying to unlock.
    let user_outputs_restricted =
      list.filter(
        self.outputs,
        fn(output) {
          when output.datum is {
            InlineDatum(output_datum) ->
              // Note that we use a soft-cast here and not an expect, because the transaction
              // might still contain other kind of outputs that we simply chose to ignore.
              // Using expect here would cause the entire transaction to be rejected for any
              // output that doesn't have a datum of that particular shape.
              if output_datum is OutputReference {
                and {
                  output.address == beneficiary,
                  own_ref == output_datum,
                }
              } else {
                False
              }
            _ -> False
          }
        },
      )

    // We sum all output values and check that the amount paid is greater than or equal to the price
    // asked by the seller.
    let value_paid =
      list.foldl(
        user_outputs_restricted,
        assets.zero,
        fn(n, acc) { merge(n.value, acc) },
      )

    (lovelace_of(value_paid) >= datum.price)?
  }
}
```

## On-Chain Data Structures

For multiple reasons, maintaining an on-chain data structure can be valuable. There are a growing number of
libraries and examples to make this easier to handle maintaining these data stuctures. Some data
structures can be maintained in a single UTxO depending on their contents and structure, others require a
number of UTxOs and are implemented as linked structures.

Each UTxO contains a reference to the next (and potentially previous) UTxO in the structure, alternatively
a trie structure could be implemented where each UTxO references any number of children along with a single
parent.

The contents of a given node on a distributed structure is arbitrary, a key value pair can be held in order
to create a distributed map using this methodology. Proving exclusion can be done in a single transaction
as long as there is a cardinal order to the entries, this is done by referencing the two UTxOs which should
have our entry between them.

## State Thread Tokens (a.k.a STT)

It is often useful to have a mutable state which either changes with each transaction, or on a periodic
basis. One way to ensure that a datum is not 'spoofed' is to ensure that the input or reference input with
that datum contains an NFT which has been generated to be unique using one of the method described above.

In this example, we will create an STT that tracks the sum of every transaction that uses the STT.

We will create a multivalidator with two responsabilities:

1. State Thread Token Minting Policy(Mint).
2. Handler of STT(Spend).

The STT Minting Policy allows us to create new tokens with a counter datum initialized at 0.

```aiken
use aiken/collection/dict
use aiken/collection/list
use cardano/address.{Script}
use cardano/assets.{PolicyId, policies}
use cardano/transaction.{InlineDatum, OutputReference, Transaction}
use config

validator counter_stt(utxo_ref: OutputReference) {
  mint(_redeemer: Data, policy_id: PolicyId, self: Transaction) {
    let Transaction { inputs, outputs, mint, .. } = self

    expect [Pair(_asset_name, quantity)] =
      mint |> assets.tokens(policy_id) |> dict.to_pairs()

    let is_output_consumed =
      list.any(inputs, fn(input) { input.output_reference == utxo_ref })

    expect Some(nft_output) =
      list.find(
        outputs,
        fn(output) { list.has(policies(output.value), policy_id) },
      )
    expect InlineDatum(datum) = nft_output.datum
    expect counter: Int = datum
    is_output_consumed? && (1 == quantity)? && counter == 0
  }
  todo @"Create the spending part to handle the STT"
}
```
Here is the part of the validator that ensures every transaction increments the value of the counter:

- We check if the transaction is signed by the operator.
- We obtain the ScriptHash to identify the NFT, which is the same as the PolicyId.
- We check if an input NFT exists and has a datum with an integer.
- We check if an output exists and has a datum with an integer.
- We check if the output datum equals the input datum + 1.

```aiken
validator counter_stt(utxo_ref: OutputReference) {

  // Mint code...

  spend(
    _optional_datum: Option<Data>,
    _redeemer: Data,
    own_ref: OutputReference,
    self: Transaction,
  ) {
    let Transaction { inputs, outputs, .. } = self
    // Getting the script hash from this validator.
    expect Some(own_input) =
      list.find(inputs, fn(input) { input.output_reference == own_ref })
    expect Script(own_script_hash) = own_input.output.address.payment_credential

    // Checking if the transaction is signed by the operator.
    let is_signed_by_operator =
      list.has(self.extra_signatories, config.operator)

    //Checking inputs
    expect Some(stt_input) =
      list.find(
        inputs,
        fn(input) { list.has(policies(input.output.value), own_script_hash) },
      )
    expect InlineDatum(input_datum) = stt_input.output.datum
    expect counter_input: Int = input_datum

    //Checking outputs
    expect Some(stt_output) =
      list.find(
        outputs,
        fn(output) { list.has(policies(output.value), own_script_hash) },
      )

    expect InlineDatum(output_datum) = stt_output.datum
    expect counter_output: Int = output_datum
    expect stt_input.output.address == stt_output.address

    //Last tx validations
    is_signed_by_operator? && (counter_output == counter_input + 1)?
  }
}
```
One important thing to point out is that we're passing the operator variable from the configuration in the aiken.toml file.

``` toml
[config.default.operator]
encoding = "hex"
bytes = "00000000000000000000000000000000000000000000000000000000"
```

And now, we can use the variable in our code like this:

```
use config

// ...
let is_signed_by_operator =
  list.has(self.extra_signatories, config.operator)
// ...
```

## Forwarding Validation & Other Withdrawal Tricks

By enforcing a given script hash to be present within the 'withdrawals' present on a given transaction,
we can effectively 'forward' the validation to this script being evaluated with the `WithdrawFrom`
script purpose.

We can leverage this to allow a script to be owner of a UTxO present in another script, where we would
normally ensure that the owner's PKH is present in the required signatories, if the credential is a
script then we ensure that the script hash is present in the withdrawals of the transaction.

By using this trick in a spending validator, we can reduce the logic in a spending validator to a
minimum and delegate the logic to either the withdrawal purpose of the same or a different validator.
This is used by a number of dApps now in production as of mid-2024 in order to optimize evaluation
budgets and reach a higher throughput for dApps as opposed to tagging outputs as discussed above.

Finally, we can combine on-chain data structures with the ability to force evaluation of a script
by storing a large number of scripts within a data-structure. Then our primary script defines within
its redeemer the script hash we are going to include in withdrawals of the tx, the logic of our
primary script can be limited to only checking that this scripthash is present in our data-structure
and present in the withdrawal category of the tx. This allows many more logical branches to exist
for a given dApp than would otherwise be possible.

## Other Reference Material

https://github.com/Anastasia-Labs/design-patterns/

https://github.com/Plutonomicon/plutonomicon/
