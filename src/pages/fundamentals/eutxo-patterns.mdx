import { Callout } from "nextra-theme-docs";

<style>{`
@font-face {
  font-family: 'Menlo Regular';
  font-style: normal;
  font-weight: normal;
  src: local('Menlo Regular'), url('/fonts/Menlo-Regular.woff') format('woff');
}
pre code {
  line-height: 1rem !important;
  font-family: "Menlo Regular" !important;
}
`}</style>

# EUTxO Patterns and Practices

There are number of design patterns that have been refined and enabled as Plutus has advanced from V1 to V2,
and now to V3. This document seeks to be a non-exhaustive reference to these design patterns and practices.

## Enforcing Uniqueness

Enforcing the uniqueness of policies, asset names, or new outputs is useful in a number of contexts.

### "One-Shot" Minting Policies

A validator is parameterized with an `OutputReference`, the minting validator enforces that the inputs to
the transaction contain the corresponding `Input`. By doing this, the minting policy is ensured to only
validate a single time. In some designs, this logic is used for only a subset of redeemers to allow more
flexible minting policies.


#### Example:
An NFT (Non-Fungible Token) can be created using a one-shot minting policy that ensures each minted value
is validated by spending a specific UTxO provided through the transaction inputs. This minting policy uses
a validator parameter of OutputReference to confirm that the transaction spends the UTxO. Additionally, the 
policy guarantees that only one token is minted, ensuring the NFT's uniqueness.

First define OutputReference as parameter and set the action type to mint or burn the token based on the 
value provided in the redeemer.

``` aiken
type Action {
  Minting
  Burning
}

validator(utxo_ref: OutputReference) {
  fn nft(action: Action, ctx: ScriptContext) -> Bool {
      todo @"mint and burn"      
    }
  }
}
```

The validator expects a minting script purpose and ensures that only one value is minted; it will fail otherwise.

``` aiken
validator(utxo_ref: OutputReference, token_name: AssetName) {
  fn nft(action: Action, ctx: ScriptContext) -> Bool {
      // It will fail the transaction if ctx.purpose is not minting
      expect Mint(policy_id) = ctx.purpose
      
      // Here we get the input, mint values, and transaction object
      let ScriptContext { transaction: Transaction { inputs, mint, .. }, .. } = ctx
      
      // It checks that only one minted value exists and will fail otherwise
      expect [(_asset_name, amount)] = mint |> from_minted_value |> tokens(policy_id) |> to_list() 

      todo @"Check if output is consumed" 

    }
  }
}
```
To enforce uniqueness, we need to ensure that the UTxO defined as OutputReference in the validator parameters is 
consumed. This is because every OutputReference is a unique combination of the Transaction ID and an Output Index
Integer. It's important to remember that the Transaction ID is a `Hash<Blake2b_256, Transaction>`, which is also a
unique identifier and will not be repeated.

``` aiken
validator(utxo_ref: OutputReference) {
  fn nft(action: Action, ctx: ScriptContext) -> Bool {
      expect Mint(policy_id) = ctx.purpose

      let ScriptContext { transaction: Transaction { inputs, mint, .. }, .. } = ctx

      expect [(_asset_name, amount)] = mint |> from_minted_value |> tokens(policy_id) |> to_list() 

      // Check if the specified UTxO reference (utxo_ref) is consumed by any input
      let is_output_consumed = list.any(inputs, fn(input) { input.output_reference == utxo_ref })

      when action is {
        Minting ->
          is_output_consumed? && (1 == amount)?

        Burning -> (-1 == amount)? // No need to check if output is consumed for burning
      }
    }
  }
}
```

### Receipts

A validator can mint a unique receipt for a transaction by requiring that the name of the asset is any
unique value specific to the transaction where validation is set to occur. In other words, if we enforce
that only one receipt is to be minted per transaction, we can use `blake2b_256` and `cbor.serialise` to
get a unique value that can be assigned to the `AssetName` expected for the receipt from the
`OutputReference` from the first `Input` in our transactions inputs.

``` aiken
validator {
  fn receipt(_r: Data, ctx: ScriptContext) -> Bool {
    // This validator expects a minting transaction
    expect Mint(policy_id) = ctx.purpose
    let ScriptContext { transaction: Transaction { inputs, mint, .. }, .. } =
      ctx

    // Select the first input and concatenate its output reference and index to generate 
    // the expected token name
    expect [Pair(asset_name, amount)] =
      mint |> from_minted_value |> tokens(policy_id) |> to_pairs()
    expect Some(first_input) = list.at(inputs, 0)
    let first_input_out_ref = first_input.output_reference
    let first_input_idx = first_input.output_reference.output_index
    let expected_token_name =
      gen_token_name(first_input_out_ref, first_input_index)

    // Compare the asset name with the first utxo output reference
    asset_name == expected_token_name && amount == 1
  }
}

// This function will generate the expected token name given the output reference
// and index from the first input of the transaction.
fn gen_token_name(
  output_reference: OutputReference,
  mint_index: Int,
) -> AssetName {
  blake2b_256(
    bytearray.concat(
      cbor.serialise(output_reference),
      string.to_bytearray(string.from_int(mint_index)),
    ),
  )
}
```

We could use this validator to mint a unique receipt for a transaction. It will get the first UTxO reference
and will compare it with the asset name.

### Unique Outputs

To prevent a vulnerability called 'Double Satisfaction' (see more below), one pattern is to ensure
that the output associated with a given input has its datum 'tagged' with a value which is unique to the
input. Enough info is present in the `OutputReference` of the input to create a unique value.

#### Double Satisfaction Anti-Pattern

In PlutusV1 and PlutusV2, a common anti-pattern was to predicate spending upon logic that was specific to
a given input - without ensuring the uniqueness of the corresponding output.

Let's walk through a short example:
Bob wants to sell 20 SCOIN and wants at least 5 ADA in return; the contract would require that at least 
5 ADA is paid to Bob.

Step-by-step swap:

  1.- Bob sends 20 SCOIN to the validator with a datum containing his VerificationKeyHash and
      the price (5 ADA) required to get the 20 SCOIN.

  2.- Alice makes a new transaction getting the 20 SCOIN and paying 5 ADA to Bob.

  3.- Alice will get 20 SCOIN.
  
  4.- Bob will get 5 ADA.


``` aiken
type VerificationKeyHash =
  Hash<Blake2b_224, VerificationKey>

type DatumSwap {
  beneficiary: VerificationKeyHash,
  price: Int,
}

validator {
  fn exploitable_swap(datum: DatumSwap, _r: Data, ctx: ScriptContext) -> Bool {
    when ctx.purpose is {
      Spend(_) -> {
        let Transaction { outputs, .. } = ctx.transaction

        let user_outputs =
          list.filter(
            outputs,
            fn(o) { o.address == from_verification_key(datum.beneficiary) },
          )

        let value_paid_to_benef =
          list.foldl(
            user_outputs,
            value.zero(),
            fn(n, acc) { value.merge(n.value, acc) },
          )

        (value.lovelace_of(value_paid_to_benef) >= datum.price)?
      }
      _ -> False
    }
  }
}
```
So far, everything is ok, but what if we have some UTxOs locked in the validator at similar prices? 

Bob wants to sell 20 XCOIN, and 20 SCOIN and wants at least 10 ADA in return for each UTxO; 
the contract would require that at least 10 ADA be paid to Bob. Now Alice comes and pays Bob 10 ADA, 
in the same transaction she takes both the 20 SCOIN and 20 XCOIN because the contract only ensures
that at least 10 ADA is paid to Bob. 

So, this validator could potentially cause the double satisfaction antipattern, where anyone can pay once and 
get every UTxO locked at the same price or less.

What can we do?
We have to ensure that each input has a corresponding unique output to pay or predicate the logic of spending any input of the
script on all of the inputs and outputs relevant to the business logic of the dApp.

Solution proposed:

First of all, we have to remember that the code in the validator will be executed for every UTxO locked to the validator address.
That we are trying to unlock. So we have to validate that every input has an output or many outputs that sum up the amount of Lovelace
asked for by the seller.

``` aiken
validator {
  fn swap(datum: DatumSwap, _r: Data, ctx: ScriptContext) -> Bool {
    when ctx.purpose is {
      Spend(curr_utxo_reference) -> {
        let Transaction { outputs, .. } = ctx.transaction

        // We will get all UTxO outputs with a datum equal to the UTxO input's reference
        // we are validating. 
        let curr_utxo_outputs =
          list.filter(
            outputs,
            fn(o) {
              when o.datum is {
                InlineDatum(output_datum) -> {
                  expect output_datum_reference: OutputReference = output_datum
                  o.address == from_verification_key(datum.beneficiary) && curr_utxo_reference == output_datum_reference
                }
                _ -> False
              }
            },
          )

        // We sum all output values and check that the amount paid is greater than or equal to the price 
        // asked by the seller.
        let paid_for_utxo =
          list.foldl(
            curr_utxo_outputs,
            value.zero(),
            fn(n, acc) { value.merge(n.value, acc) },
          )

        (value.lovelace_of(paid_for_utxo) >= datum.price)?
      }
      _ -> False
    }
  }
}
```

## On-Chain Data Structures

For multiple reasons, maintaining an on-chain data structure can be valuable. There are a growing number of
libraries and examples to make this easier to handle maintaining these data stuctures. Some data
structures can be maintained in a single UTxO depending on their contents and structure, others require a
number of UTxOs and are implemented as linked structures.

Each UTxO contains a reference to the next (and potentially previous) UTxO in the structure, alternatively
a trie structure could be implemented where each UTxO references any number of children along with a single
parent.

The contents of a given node on a distributed structure is arbitrary, a key value pair can be held in order
to create a distributed map using this methodology. Proving exclusion can be done in a single transaction
as long as there is a cardinal order to the entries, this is done by referencing the two UTxOs which should
have our entry between them.

## State Thread Tokens

It is often useful to have a mutable state which either changes with each transaction, or on a periodic
basis. One way to ensure that a datum is not 'spoofed' is to ensure that the input or reference input with
that datum contains an NFT which has been generated to be unique using one of the method described above.

### STT Example:
In this example, we will create an STT that tracks the sum of every transaction that uses the STT.

We will create two different validators:

1. State Thread Token Minting Policy.
2. Handler of STT.

The STT Minting Policy allows us to create new tokens with a counter datum initialized at 0.

```aiken
use aiken/dict.{to_pairs}
use aiken/list
use aiken/transaction.{
  InlineDatum, Mint, OutputReference, ScriptContext, Transaction,
}
use aiken/transaction/value.{from_minted_value, tokens}

validator(utxo_ref: OutputReference) {
  fn counter_stt(_r: Data, ctx: ScriptContext) -> Bool {
    expect Mint(policy_id) = ctx.purpose
    let ScriptContext {
      transaction: Transaction { inputs, outputs, mint, .. },
      ..
    } = ctx

    expect [Pair(_asset_name, amount)] =
      mint |> from_minted_value |> tokens(policy_id) |> to_pairs()

    let is_output_consumed =
      list.any(inputs, fn(input) { input.output_reference == utxo_ref })

    expect [nft_output] =
      list.filter(
        outputs,
        fn(output) { list.has(value.policies(output.value), policy_id) },
      )
    expect InlineDatum(datum) = nft_output.datum
    expect counter: Int = datum
    is_output_consumed? && (1 == amount)? && counter == 0
  }
}
```
Here is the script that will ensure that every transaction increments the value of the counter:

- We check if the transaction is signed by the operator.
- We check if an input NFT exists and has a datum with an integer.
- We check if an output exists and has a datum with an integer.
- We check if the output datum equals the input datum + 1.

```aiken
type VerificationKeyHash =
  Hash<Blake2b_224, VerificationKey>

type HandlerParams {
  nft: PolicyId,
  operator: VerificationKeyHash,
}

validator(params: HandlerParams) {
  fn handler(_r: Data, _d: Data, ctx: ScriptContext) -> Bool {
    when ctx.purpose is {
      Spend(_) -> {
        let Transaction { inputs, outputs, .. } = ctx.transaction
        // Checking if the transaction is signed by the operator.
        let is_signed_by_operator =
          list.has(ctx.transaction.extra_signatories, params.operator)

        //Checking inputs
        expect [stt_input] =
          list.filter(
            inputs,
            fn(input) { list.has(policies(input.output.value), params.nft) },
          )
        expect InlineDatum(input_datum) = stt_input.output.datum
        expect counter_input: Int = input_datum

        //Checking outputs
        expect [stt_output] =
          list.filter(
            outputs,
            fn(output) { list.has(policies(output.value), params.nft) },
          )

        expect InlineDatum(output_datum) = stt_output.datum
        expect counter_output: Int = output_datum
        expect stt_input.output.address == stt_output.address

        //Last tx validations
        is_signed_by_operator? && (counter_output == counter_input + 1)?
      }
      _ -> False
    }
  }
}
```

## Forwarding Validation & Other Withdrawal Tricks

By enforcing a given script hash to be present within the 'withdrawals' present on a given transaction,
we can effectively 'forward' the validation to this script being evaluated with the `WithdrawFrom`
script purpose.

We can leverage this to allow a script to be owner of a UTxO present in another script, where we would
normally ensure that the owner's PKH is present in the required signatories, if the credential is a
script then we ensure that the script hash is present in the withdrawals of the transaction.

By using this trick in a spending validator, we can reduce the logic in a spending validator to a
minimum and delegate the logic to either the withdrawal purpose of the same or a different validator.
This is used by a number of dApps now in production as of mid-2024 in order to optimize evaluation
budgets and reach a higher throughput for dApps as opposed to tagging outputs as discussed above.

Finally, we can combine on-chain data structures with the ability to force evaluation of a script
by storing a large number of scripts within a data-structure. Then our primary script defines within
its redeemer the script hash we are going to include in withdrawals of the tx, the logic of our
primary script can be limited to only checking that this scripthash is present in our data-structure
and present in the withdrawal category of the tx. This allows many more logical branches to exist
for a given dApp than would otherwise be possible.

## Other Reference Material

https://github.com/Anastasia-Labs/design-patterns/

https://github.com/Plutonomicon/plutonomicon/